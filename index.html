<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>takepanda</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        touch-action: manipulation;
        -webkit-user-select: none;
        user-select: none;
      }

      #container {
        position: relative;
        width: 100vw;
        height: 100vh;
        background: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      canvas {
        background: rgb(170, 255, 170);
        border: 2px solid #333;
        width: 90vw;
        max-width: 400px;
        height: auto;
        touch-action: none;
      }

      #retryButton {
        display: none;
        position: absolute;
        top: 65%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 10px 20px;
        font-size: 18px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        z-index: 3;
      }

      #leftZone,
      #rightZone {
        position: absolute;
        top: 0;
        width: 50%;
        height: 100%;
        z-index: 2;
      }

      #leftZone {
        left: 0;
      }
      #rightZone {
        right: 0;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <canvas id="gameCanvas" width="400" height="600"></canvas>
      <button id="retryButton">リトライ</button>
      <div id="leftZone"></div>
      <div id="rightZone"></div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const retryButton = document.getElementById("retryButton");
      const leftZone = document.getElementById("leftZone");
      const rightZone = document.getElementById("rightZone");

      const images = {};
      const imageSources = {
        pan: "images/character/pan.png",
        panda: "images/character/panda.png",
        panLeft: "images/character/pan(h).png",
        panRight: "images/character/pan(m).png",
        banLeft: "images/character/ban(h).png",
        banRight: "images/character/ban(m).png",
        trunk: "images/ground/take.png",
        branchLeft: "images/ground/happa(h).png",
        branchRight: "images/ground/happa(m).png",
      };

      const playerImageProperties = {
        pan: { width: 75, height: 75, x: 130, y: 510 },
        panda: { width: 75, height: 75, x: 195, y: 510 },
        panLeft: { width: 58, height: 76, x: 130, y: 510 },
        panRight: { width: 58, height: 76, x: 210, y: 510 },
      };

      const attackEffectProperties = {
        banLeft: { width: 40, height: 40, x: 180, y: 500 },
        banRight: { width: 33, height: 33, x: 180, y: 510 },
      };

      const tree = [];
      let score = 0,
        timer = 30,
        gameOver = false,
        isAnimating = false;
      let gameStarted = false;
      let playerSide = "left";
      let lastBranch = "none";
      let pandaVisible = true;
      let showAttackEffect = false,
        attackEffectSide = "left",
        attackEffectTimer = 0;
      let startTime = null;

      // 読み込み管理
      let loaded = 0;
      const totalImages = Object.keys(imageSources).length;
      for (let key in imageSources) {
        images[key] = new Image();
        images[key].src = imageSources[key];
        images[key].onload = () => {
          loaded++;
          if (loaded === totalImages) startGame();
        };
      }

      // タッチによるズーム防止
      let lastTouchTime = 0;
      document.addEventListener(
        "touchstart",
        function (e) {
          const now = new Date().getTime();
          if (now - lastTouchTime <= 300) {
            e.preventDefault(); // ダブルタップ時拡大を防ぐ
          }
          lastTouchTime = now;
        },
        { passive: false }
      );

      // ダブルタップズーム防止 (特定要素に touchend を使っても良い)
      leftZone.addEventListener(
        "touchend",
        (e) => {
          e.preventDefault();
        },
        { passive: false }
      );

      rightZone.addEventListener(
        "touchend",
        (e) => {
          e.preventDefault();
        },
        { passive: false }
      );

      function generateBranch() {
        const elapsed = (Date.now() - startTime) / 1000;
        const prob = Math.min(0.2 + elapsed * 0.02, 0.7);
        let branch;
        do {
          const rand = Math.random();
          if (rand < prob / 2) branch = "left";
          else if (rand < prob) branch = "right";
          else branch = "none";
        } while (
          (lastBranch === "left" && branch === "right") ||
          (lastBranch === "right" && branch === "left")
        );
        lastBranch = branch;
        return branch;
      }

      function initTree() {
        tree.length = 0;
        lastBranch = "none";
        for (let i = 0; i < 6; i++) {
          tree.push({
            branch: i === 0 ? "none" : generateBranch(),
            yOffset: i * 80,
          });
        }
      }

      function drawTree() {
        tree.forEach((t, i) => {
          const y = 500 - t.yOffset;
          ctx.drawImage(images.trunk, 180, y, 40, 87);
          if (t.branch === "left")
            ctx.drawImage(images.branchLeft, 98, y, 90, 70);
          else if (t.branch === "right")
            ctx.drawImage(images.branchRight, 212, y, 90, 70);
        });
      }

      function drawPlayer() {
        if (!pandaVisible) return;
        const key = !gameStarted
          ? playerSide === "left"
            ? "pan"
            : "panda"
          : playerSide === "left"
          ? "panLeft"
          : "panRight";
        const img = images[key];
        const props = playerImageProperties[key];
        ctx.drawImage(img, props.x, props.y, props.width, props.height);
      }

      function drawAttackEffect() {
        if (showAttackEffect && attackEffectTimer > 0) {
          const key = attackEffectSide === "left" ? "banLeft" : "banRight";
          const img = images[key];
          const props = attackEffectProperties[key];
          ctx.drawImage(img, props.x, props.y, props.width, props.height);
          attackEffectTimer--;
          if (attackEffectTimer <= 0) showAttackEffect = false;
        }
      }

      function checkCollision() {
        const topBranch = tree[0].branch;
        if (
          (topBranch === "left" && playerSide === "left") ||
          (topBranch === "right" && playerSide === "right")
        ) {
          gameOver = true;
        }
      }

      function chop() {
        if (gameOver || isAnimating || !gameStarted) return;
        isAnimating = true;
        score++;

        tree.shift();
        tree.forEach((b) => (b.yOffset -= 80));
        tree.push({ branch: generateBranch(), yOffset: 400 });

        showAttackEffect = true;
        attackEffectSide = playerSide;
        attackEffectTimer = 3;

        isAnimating = false;
        checkCollision();
      }

      function startGame() {
        initTree();
        startTime = Date.now();

        setInterval(() => {
          if (!gameOver && gameStarted) {
            timer--;
            if (timer <= 0) gameOver = true;
          }
        }, 1000);

        retryButton.addEventListener("click", () => {
          score = 0;
          timer = 30;
          gameOver = false;
          gameStarted = false;
          pandaVisible = true;
          playerSide = "left";
          showAttackEffect = false;
          attackEffectTimer = 0;
          retryButton.style.display = "none";
          initTree();
          startTime = Date.now();
        });

        window.addEventListener("keydown", (e) => {
          if (gameOver) return;
          if (e.key === "ArrowLeft") playerSide = "left";
          else if (e.key === "ArrowRight") playerSide = "right";
          else if (e.key === " " || e.code === "Space") {
            gameStarted = true;
            chop();
          }
          checkCollision();
        });

        leftZone.addEventListener("touchstart", () => {
          if (gameOver) return;
          playerSide = "left";
          gameStarted = true;
          chop();
        });

        rightZone.addEventListener("touchstart", () => {
          if (gameOver) return;
          playerSide = "right";
          gameStarted = true;
          chop();
        });

        gameLoop();
      }

      function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawTree();
        drawPlayer();
        drawAttackEffect();

        ctx.fillStyle = "#000";
        ctx.font = "20px sans-serif";
        ctx.fillText(`Score: ${score}`, 10, 30);
        ctx.fillText(`Time: ${timer}`, 300, 30);

        if (gameOver) {
          ctx.fillStyle = "red";
          ctx.font = "36px sans-serif";
          ctx.fillText(timer <= 0 ? "   Finish!!" : "Game Over", 100, 300);
          retryButton.style.display = "block";
        }

        requestAnimationFrame(gameLoop);
      }
    </script>
  </body>
</html>
